<!-- TOC -->

- [1. 说明](#1-说明)
- [2. 取整的思考方法](#2-取整的思考方法)
- [3. 排名的思考方法](#3-排名的思考方法)
- [4. 删除的思考方法](#4-删除的思考方法)
- [5. 范围查找的思考方法](#5-范围查找的思考方法)

<!-- /TOC -->

<a id="markdown-1-说明" name="1-说明"></a>
# 1. 说明

> 一棵二叉查找树(BST)是一棵二叉树,其中每个结点的键都`大于`其`左子树中`的任意结点的键而`小于` `右子树`的任意结点的键


实现:
* size 某个结点的子树结点总数 / 树的所有结点数(包括根结点)
* get 查找
* put 插入
* min 最小键
* max 最大键
* floor 向下取整 (寻找<=key的最大key)
* ceiling 向上取整 (寻找>=key的最小key)
* select 查找排名为k的键  (排名范围[0,k])
* rank 返回键的排名 (返回 < key 的键的数量)
* delete 删除键
* deleteMin 删除最小键 
* deleteMax 删除最大键
* keys 范围查找

额外:  
深度和高度:  
https://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height

打印bst:  
https://stackoverflow.com/questions/4965335/how-to-print-binary-tree-diagram
* 树的高度和深度 
* 打印树 

<a id="markdown-2-取整的思考方法" name="2-取整的思考方法"></a>
# 2. 取整的思考方法

floor 向下取整也就是寻找`<=key`的`最大值`

key在树中递归查找,3种情况:
1. node.key == key. 返回这个node,相等就是最大的了
2. node.key < key. 继续向node的右子树前进,寻找`小于等于key的最大值`
3. node.key > key. 向node的左子树前进,寻找小于key的情况

ceiling 向上取整也就是寻找`>=key`的`最小值`

1. node.key == key. 返回这个node,相等就是最小的了
2. node.key < key. 向node的右子树前进,寻找大于key的情况
3. node.key > key. 继续向node的左子树前进,寻找`大于等于key的最小值`

<a id="markdown-3-排名的思考方法" name="3-排名的思考方法"></a>
# 3. 排名的思考方法

select 查找排名为k的键

1. 左子结点的数量 == k. 返回这个node
2. 左子结点的数量 > k. 继续向node的左子树前进,寻找`排名位k的键`
3. 左子结点的数量 < k. 排除包含node在内左边部分,并累积排名查找右子树

rank 返回 < key 的键的数量

1. key == node.key. 返回node左子树的结点数
2. key < node.key. 继续向左子树前进,寻找`< key 的键的数量`
3. key > node.key. 把包含node在内左边部分的数量算上,继续寻找右子树

<a id="markdown-4-删除的思考方法" name="4-删除的思考方法"></a>
# 4. 删除的思考方法


删除最小键:

* 递归向下,当结点左结点为nil时,为`最小键`,而它的右结点为`第二小`的键,返回该结点 (如果左结点不为nil则继续递归向下, 待递归走出来后,重新计算n并返回自身)


删除最大键:

* 递归向下,当结点右结点位nil,时,为`最大键`,而它的左结点为`第二大`的键,返回该结点 (如果右结点部位nil则继续递归向下, 待递归走出来后,重新计算n并返回自身)

删除:

* 还是延续上面的思路,递归向下删除,键不相等时,需要重新计算n,并返回自身
* 相等时有3种情况:
  * 左,右都为nil,最简单的情况,直接删除
  * 左为nil,返回右. 右为nil,返回左
  * 左右都有值.思路:需要用什么样的值来代替自己?来达到1.比左子树大 2.比右子树小? 比左子树大->key在右子树. 比右子树小->key是右子树的最小key!


<a id="markdown-5-范围查找的思考方法" name="5-范围查找的思考方法"></a>
# 5. 范围查找的思考方法

* 递归向下,判断范围是否继续向左子树,或右子树加入,当前值在范围内就是加入到队列中
* 按照顺序,是左->中->右,所以应该是中序遍历的方式

